<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Generator — Build</title>
  <style>
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(135deg,#7eb3c4 0%,#9cc9d4 100%);color:#1a1a1a;display:flex;align-items:center;justify-content:center;height:100vh}
    .box{background:rgba(255,255,255,0.15);backdrop-filter:blur(10px);padding:36px;border-radius:20px;max-width:920px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.15)}
    h1{margin:0 0 12px;font-size:28px;color:#1a1a1a}
    p{color:#333}
    .btn-primary{margin-top:20px;padding:12px 18px;border-radius:10px;background:#000;color:#fff;text-decoration:none;font-weight:700;border:none;display:inline-flex;align-items:center;gap:8px}
    .btn-primary:hover{background:#222}
  </style>
</head>
<body>
  <div class="box">
    <h1>App Generation — Painter</h1>
    <p>Use the tools to add shapes, pick colors, edit text, and compose on the whiteboard.</p>

    <div style="display:flex;gap:18px;margin-top:18px;align-items:flex-start">
      <!-- Tools column -->
      <div style="width:300px">
        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px">
          <strong>Shapes</strong>
          <div id="shapes" style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
            <button class="tool" data-shape="rect">▭</button>
            <button class="tool" data-shape="rounded">▣</button>
            <button class="tool" data-shape="circle">◯</button>
            <button class="tool" data-shape="ellipse">◔</button>
            <button class="tool" data-shape="triangle">△</button>
            <button class="tool" data-shape="star">★</button>
            <button class="tool" data-shape="line">／</button>
            <button class="tool" data-shape="text">T</button>
          </div>
        </div>

        <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px">
          <strong>Color palette</strong>
          <div id="palette" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px">
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <input id="colorPicker" type="color" value="#7C4DFF" title="Pick color" style="width:42px;height:34px;border:none;padding:0;background:transparent;cursor:pointer">
            <button id="addColorBtn" class="tool">Add</button>
          </div>
        </div>

        <div id="textControls" style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;display:none">
          <strong>Text options</strong>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="boldBtn" class="tool">B</button>
            <button id="italicBtn" class="tool">I</button>
            <button id="underlineBtn" class="tool">U</button>
          </div>
          <div style="margin-top:8px">
            <input id="textInput" type="text" placeholder="Edit selected text" style="width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit">
          </div>
        </div>

        <div id="appearanceControls" style="background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-top:12px">
          <strong>Appearance</strong>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px"><input id="fillToggle" type="checkbox" checked> Fill</label>
            <label style="display:flex;align-items:center;gap:6px">Stroke: <input id="strokeColorPicker" type="color" value="#000000" style="margin-left:6px"></label>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <label style="font-size:13px">Width</label>
            <input id="strokeWidth" type="range" min="0" max="12" value="2">
            <select id="strokeStyle">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="deleteBtn" class="tool" style="background:lab(45.73% 70.62 57.65);color:#fff">Delete</button>
          </div>
        </div>
      </div>

      <!-- Whiteboard column -->
      <div style="flex:1">
        <div id="whiteboard" style="background:#ffffff;border-radius:8px;height:520px;position:relative;overflow:hidden;box-shadow:0 8px 30px rgba(2,6,23,0.2)"></div>
        <div style="margin-top:10px;display:flex;gap:12px">
          <button id="clearBtn" class="btn-primary">Clear</button>
          <a class="btn-primary" href="post_login.html">Back</a>
        </div>
      </div>
    </div>

    <style>
      .tool{background:transparent;border:1px solid rgba(0,0,0,0.06);padding:8px 10px;border-radius:8px;color:#1a1a1a;font-weight:700;cursor:pointer}
      .tool:hover{transform:translateY(-2px)}
      .palette-swatch{width:34px;height:34px;border-radius:6px;border:2px solid rgba(0,0,0,0.06);cursor:pointer}
      .resize-handle{position:absolute;width:12px;height:12px;background:#fff;border-radius:2px;right:-6px;bottom:-6px;cursor:se-resize;box-shadow:0 2px 6px rgba(2,6,23,0.2);pointer-events:auto}
      .shape{position:absolute;cursor:grab;display:flex;align-items:center;justify-content:center}
      .shape.selected{outline:3px dashed rgba(124,77,255,0.7)}
      .shape.dragging{cursor:grabbing;opacity:0.9}
      .text-shape{padding:6px 10px;border-radius:6px;background:transparent;color:#1a1a1a}
    </style>

    <script>
      (function(){
        const colors = ['#0EA5E9','#7C4DFF','#06D6A0','#FFB703','#EF476F','#FFFFFF','#000000','#F97316','#06B6D4','#FB7185','#FB923C','#34D399'];
        const palette = document.getElementById('palette');
        const colorPicker = document.getElementById('colorPicker');
        const addColorBtn = document.getElementById('addColorBtn');
        const fillToggle = document.getElementById('fillToggle');
        const strokeColorPicker = document.getElementById('strokeColorPicker');
        const strokeWidth = document.getElementById('strokeWidth');
        const strokeStyle = document.getElementById('strokeStyle');
        const deleteBtn = document.getElementById('deleteBtn');
        const shapesEl = document.getElementById('shapes');
        const whiteboard = document.getElementById('whiteboard');
        const textControls = document.getElementById('textControls');
        const textInput = document.getElementById('textInput');
        const boldBtn = document.getElementById('boldBtn');
        const italicBtn = document.getElementById('italicBtn');
        const underlineBtn = document.getElementById('underlineBtn');
        const clearBtn = document.getElementById('clearBtn');

        let currentColor = colors[0];
        let currentTool = 'rect';
        let selectedEl = null;
        let hoverEl = null;
        let fillMode = true;
        let currentStrokeColor = '#000000';
        let currentStrokeWidth = 2;
        let currentStrokeStyle = 'solid';

        // build palette
        colors.forEach(c => {
          const sw = document.createElement('div');
          sw.className = 'palette-swatch';
          sw.style.background = c;
          sw.dataset.color = c;
          sw.addEventListener('click', () => {
            currentColor = c;
            const target = hoverEl || selectedEl;
            if (target) applyColorTo(target, c);
          });
          palette.appendChild(sw);
        });

        addColorBtn.addEventListener('click', () => {
          const c = colorPicker.value;
          if (!c) return;
          const sw = document.createElement('div');
          sw.className = 'palette-swatch';
          sw.style.background = c;
          sw.dataset.color = c;
          sw.addEventListener('click', () => { currentColor = c; const target = hoverEl || selectedEl; if(target) applyColorTo(target,c); });
          palette.appendChild(sw);
        });

        if(fillToggle) fillToggle.addEventListener('change', (e) => { fillMode = e.target.checked; const target = hoverEl || selectedEl; if(target) applyAppearance(target); });
        if(strokeColorPicker) strokeColorPicker.addEventListener('input', (e) => { currentStrokeColor = e.target.value; const target = hoverEl || selectedEl; if(target) applyAppearance(target); });
        if(strokeWidth) strokeWidth.addEventListener('input', (e) => { currentStrokeWidth = parseInt(e.target.value); const target = hoverEl || selectedEl; if(target) applyAppearance(target); });
        if(strokeStyle) strokeStyle.addEventListener('change', (e) => { currentStrokeStyle = e.target.value; const target = hoverEl || selectedEl; if(target) applyAppearance(target); });
        if(deleteBtn) deleteBtn.addEventListener('click', () => { if(selectedEl){ selectedEl.remove(); selectedEl = null; textControls.style.display='none'; } });

        document.addEventListener('keydown', (e) => {
          if((e.key === 'Delete' || e.key === 'Backspace') && selectedEl){ selectedEl.remove(); selectedEl = null; textControls.style.display='none'; }
        });

        shapesEl.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-shape]');
          if (!btn) return;
          currentTool = btn.dataset.shape;
          textControls.style.display = currentTool === 'text' ? 'block' : 'none';
        });

        whiteboard.addEventListener('dblclick', (ev) => {
          const rect = whiteboard.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          addShape(currentTool, x, y);
        });

        clearBtn.addEventListener('click', () => { whiteboard.innerHTML = ''; selectedEl = null; textControls.style.display='none'; });

        function addShape(type, x=120, y=120){
          let el = document.createElement('div');
          el.className = 'shape';
          el.style.left = (x - 50) + 'px';
          el.style.top = (y - 30) + 'px';
          el.dataset.type = type;
          el.dataset.color = currentColor;

          if(type === 'rect'){
            el.style.width = '120px'; el.style.height = '80px'; el.style.borderRadius='10px';
            if(fillMode){ el.style.background = currentColor; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; } else { el.style.background = 'transparent'; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
          } else if(type === 'rounded'){
            el.style.width = '130px'; el.style.height = '84px'; el.style.borderRadius='20px';
            if(fillMode){ el.style.background = currentColor; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; } else { el.style.background = 'transparent'; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
          } else if(type === 'circle'){
            el.style.width = '100px'; el.style.height = '100px'; el.style.borderRadius='50%';
            if(fillMode){ el.style.background = currentColor; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; } else { el.style.background = 'transparent'; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
          } else if(type === 'ellipse'){
            el.style.width = '140px'; el.style.height = '80px'; el.style.borderRadius='50% / 60%';
            if(fillMode){ el.style.background = currentColor; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; } else { el.style.background = 'transparent'; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
          } else if(type === 'triangle'){
            const tri = document.createElementNS('http://www.w3.org/2000/svg','svg');
            tri.setAttribute('viewBox','0 0 100 100'); tri.setAttribute('width','120'); tri.setAttribute('height','120');
            const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
            poly.setAttribute('points','50,10 90,85 10,85');
            if(fillMode){ poly.setAttribute('fill', currentColor); poly.setAttribute('stroke','none'); } else { poly.setAttribute('fill','none'); poly.setAttribute('stroke', currentStrokeColor); poly.setAttribute('stroke-width', currentStrokeWidth); poly.setAttribute('stroke-dasharray', currentStrokeStyle === 'dashed' ? '8 6' : (currentStrokeStyle==='dotted'?'2 4':'0')); }
            tri.appendChild(poly);
            el.appendChild(tri);
            el.style.width='120px'; el.style.height='120px';
          } else if(type === 'line'){
            el.style.width = '160px'; el.style.height = '4px'; el.style.borderRadius='2px';
            if(fillMode){ el.style.background = currentColor; el.style.border = 'none'; } else { el.style.background = 'transparent'; el.style.border = 'none';
              const ln = document.createElementNS('http://www.w3.org/2000/svg','svg'); ln.setAttribute('width','160'); ln.setAttribute('height','20'); const l = document.createElementNS('http://www.w3.org/2000/svg','line'); l.setAttribute('x1','0'); l.setAttribute('y1','10'); l.setAttribute('x2','160'); l.setAttribute('y2','10'); l.setAttribute('stroke',currentStrokeColor); l.setAttribute('stroke-width',currentStrokeWidth); if(currentStrokeStyle==='dashed') l.setAttribute('stroke-dasharray','8 6'); if(currentStrokeStyle==='dotted') l.setAttribute('stroke-dasharray','2 4'); ln.appendChild(l); el.appendChild(ln);
            }
          } else if(type === 'star'){
            const svgEl = document.createElementNS('http://www.w3.org/2000/svg','svg');
            svgEl.setAttribute('viewBox','0 0 24 24'); svgEl.setAttribute('width','80'); svgEl.setAttribute('height','80');
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            path.setAttribute('d','M12 .587l3.668 7.431L23.5 9.75l-5.75 5.602L19.335 24 12 19.897 4.665 24l1.584-8.648L.5 9.75l7.832-1.732L12 .587z');
            if(fillMode){ path.setAttribute('fill', currentColor); path.setAttribute('stroke','none'); }
            else { path.setAttribute('fill','none'); path.setAttribute('stroke', currentStrokeColor); path.setAttribute('stroke-width', currentStrokeWidth); if(currentStrokeStyle==='dashed') path.setAttribute('stroke-dasharray','8 6'); if(currentStrokeStyle==='dotted') path.setAttribute('stroke-dasharray','2 4'); }
            svgEl.appendChild(path);
            el.appendChild(svgEl);
            el.style.width='100px'; el.style.height='100px';
            el.style.pointerEvents = 'auto';
          } else if(type === 'text'){
            el.classList.add('text-shape');
            el.contentEditable = true;
            el.innerText = 'Edit me';
            el.style.background = 'transparent';
            el.style.color = '#000';
            el.style.minWidth = '80px';
          }

          const needsHandle = ['rect','rounded','circle','ellipse','star','text','triangle','line'].includes(type);

          whiteboard.appendChild(el);
          makeSelectable(el);
          makeDraggable(el);
          if(needsHandle) makeResizable(el, type);
          applyAppearance(el);
          selectElement(el);
        }

        function applyColorTo(el, color){
          if(!el) return;
          if(el.dataset.type === 'star'){
            const path = el.querySelector('path');
            if(path) path.setAttribute('fill', color);
            el.dataset.color = color;
          } else if(el.dataset.type === 'triangle'){
            const poly = el.querySelector('polygon'); if(poly){ poly.setAttribute('fill', color); }
            el.dataset.color = color;
          } else if(el.dataset.type === 'line'){
            const ln = el.querySelector('line'); if(ln) ln.setAttribute('stroke', color);
            el.dataset.color = color;
          } else if(el.dataset.type === 'text'){
            el.style.color = color === '#FFFFFF' ? '#000' : color;
            el.dataset.color = color;
          } else {
            el.style.background = color;
            el.dataset.color = color;
          }
        }

        function applyAppearance(el){
          if(!el) return;
          const type = el.dataset.type;
          if(type === 'star'){
            const path = el.querySelector('path'); if(!path) return;
            if(fillMode){ path.setAttribute('fill', currentColor); path.setAttribute('stroke','none'); }
            else { path.setAttribute('fill','none'); path.setAttribute('stroke', currentStrokeColor); path.setAttribute('stroke-width', currentStrokeWidth); path.setAttribute('stroke-dasharray', currentStrokeStyle==='dashed'?'8 6':(currentStrokeStyle==='dotted'?'2 4':'0')); }
            el.dataset.fillMode = fillMode;
            el.dataset.strokeColor = currentStrokeColor;
            el.dataset.strokeWidth = currentStrokeWidth;
            el.dataset.strokeStyle = currentStrokeStyle;
            el.dataset.color = currentColor;
          } else if(type === 'triangle'){
            const poly = el.querySelector('polygon'); if(!poly) return;
            if(fillMode){ poly.setAttribute('fill', currentColor); poly.setAttribute('stroke','none'); }
            else { poly.setAttribute('fill','none'); poly.setAttribute('stroke', currentStrokeColor); poly.setAttribute('stroke-width', currentStrokeWidth); poly.setAttribute('stroke-dasharray', currentStrokeStyle==='dashed'?'8 6':(currentStrokeStyle==='dotted'?'2 4':'0')); }
            el.dataset.fillMode = fillMode;
            el.dataset.strokeColor = currentStrokeColor;
            el.dataset.strokeWidth = currentStrokeWidth;
            el.dataset.strokeStyle = currentStrokeStyle;
            el.dataset.color = currentColor;
          } else if(type === 'line'){
            const ln = el.querySelector('line'); if(ln){ ln.setAttribute('stroke', currentStrokeColor); ln.setAttribute('stroke-width', currentStrokeWidth); if(currentStrokeStyle==='dashed') ln.setAttribute('stroke-dasharray','8 6'); else if(currentStrokeStyle==='dotted') ln.setAttribute('stroke-dasharray','2 4'); else ln.removeAttribute('stroke-dasharray'); }
            el.dataset.fillMode = fillMode;
            el.dataset.strokeColor = currentStrokeColor;
            el.dataset.strokeWidth = currentStrokeWidth;
            el.dataset.strokeStyle = currentStrokeStyle;
            el.dataset.color = currentColor;
          } else if(type === 'text'){
            if(fillMode){ el.style.color = currentColor; el.style.webkitTextStroke = '0px'; }
            else { el.style.color = currentStrokeColor; el.style.webkitTextStroke = (currentStrokeWidth/6) + 'px ' + currentStrokeColor; }
            el.dataset.fillMode = fillMode;
            el.dataset.strokeColor = currentStrokeColor;
            el.dataset.strokeWidth = currentStrokeWidth;
            el.dataset.strokeStyle = currentStrokeStyle;
            el.dataset.color = currentColor;
          } else {
            if(fillMode){ el.style.background = currentColor; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
            else { el.style.background = 'transparent'; el.style.border = `${currentStrokeWidth}px ${currentStrokeStyle} ${currentStrokeColor}`; el.style.boxSizing = 'border-box'; }
            el.dataset.fillMode = fillMode;
            el.dataset.strokeColor = currentStrokeColor;
            el.dataset.strokeWidth = currentStrokeWidth;
            el.dataset.strokeStyle = currentStrokeStyle;
            el.dataset.color = currentColor;
          }
        }

        function makeSelectable(el){
          el.addEventListener('click', (ev) => { ev.stopPropagation(); selectElement(el); });
          el.addEventListener('mouseenter', () => { hoverEl = el; });
          el.addEventListener('mouseleave', () => { if(hoverEl === el) hoverEl = null; });
        }

        function removeResizeHandle(el){
          const h = el.querySelector('.resize-handle'); if(h) h.remove();
        }

        function makeResizable(el, type){
          removeResizeHandle(el);
          const handle = document.createElement('div');
          handle.className = 'resize-handle';
          el.appendChild(handle);

          let startW=0, startH=0, startX=0, startY=0;
          function onDown(e){
            e.stopPropagation();
            startW = el.offsetWidth; startH = el.offsetHeight;
            startX = e.clientX; startY = e.clientY;
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          }
          function onMove(e){
            const dx = e.clientX - startX; const dy = e.clientY - startY;
            let newW = Math.max(24, startW + dx);
            let newH = Math.max(24, startH + dy);
            if(type === 'circle'){
              const s = Math.max(newW, newH); newW = s; newH = s; el.style.borderRadius='50%';
            }
            if(type === 'star'){
              el.style.width = newW + 'px'; el.style.height = newH + 'px';
              const svg = el.querySelector('svg'); if(svg){ svg.setAttribute('width', newW); svg.setAttribute('height', newH); }
            } else if(type === 'text'){
              const size = Math.max(10, Math.round(newW/8)); el.style.fontSize = size + 'px';
              el.style.minWidth = newW + 'px';
            } else {
              el.style.width = newW + 'px'; el.style.height = newH + 'px';
            }
          }
          function onUp(){ document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); }
          handle.addEventListener('mousedown', onDown);
        }

        function selectElement(el){
          if(selectedEl) selectedEl.classList.remove('selected');
          selectedEl = el;
          if(selectedEl) selectedEl.classList.add('selected');
          textControls.style.display = selectedEl && selectedEl.dataset.type === 'text' ? 'block' : 'none';
          if(selectedEl) {
            const c = selectedEl.dataset.color || currentColor;
            currentColor = c;
            if(typeof selectedEl.dataset.fillMode !== 'undefined') fillMode = selectedEl.dataset.fillMode === 'true';
            if(selectedEl.dataset.strokeColor) currentStrokeColor = selectedEl.dataset.strokeColor;
            if(selectedEl.dataset.strokeWidth) currentStrokeWidth = selectedEl.dataset.strokeWidth;
            if(selectedEl.dataset.strokeStyle) currentStrokeStyle = selectedEl.dataset.strokeStyle;

            if(fillToggle) fillToggle.checked = !!fillMode;
            if(strokeColorPicker) strokeColorPicker.value = currentStrokeColor || '#000000';
            if(strokeWidth) strokeWidth.value = currentStrokeWidth || 2;
            if(strokeStyle) strokeStyle.value = currentStrokeStyle || 'solid';

            applyAppearance(selectedEl);

            if(selectedEl.dataset.type === 'text') textInput.value = selectedEl.innerText;
          }
        }

        whiteboard.addEventListener('click', () => { if(selectedEl){ selectedEl.classList.remove('selected'); selectedEl = null; textControls.style.display='none'; } });

        boldBtn.addEventListener('click', () => { const target = hoverEl || selectedEl; if(target && target.dataset.type==='text') toggleStyle('fontWeight','700','400', target); });
        italicBtn.addEventListener('click', () => { const target = hoverEl || selectedEl; if(target && target.dataset.type==='text') toggleStyle('fontStyle','italic','normal', target); });
        underlineBtn.addEventListener('click', () => { const target = hoverEl || selectedEl; if(target && target.dataset.type==='text') toggleStyle('textDecoration','underline','none', target); });

        textInput.addEventListener('input', () => { const target = hoverEl || selectedEl; if(target && target.dataset.type==='text') target.innerText = textInput.value; });

        function toggleStyle(prop, a, b, el){
          const target = el || selectedEl; if(!target) return;
          const cur = target.style[prop];
          target.style[prop] = cur === a ? b : a;
        }

        function makeDraggable(el){
          el.style.touchAction = 'none';
        }

        // Improved dragging with smooth mouse tracking
        (function(){
          let dragEl = null;
          let startX = 0, startY = 0, startLeft = 0, startTop = 0;
          let isTextEditing = false;

          function onDown(e){
            if (e.button !== 0) return;
            const targetShape = e.target.closest && e.target.closest('.shape');
            if (!targetShape) return;
            
            // Don't drag if resizing or clicking inputs
            if (e.target && (e.target.classList && e.target.classList.contains('resize-handle'))) return;
            if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT')) return;
            
            e.preventDefault();
            dragEl = targetShape;
            selectElement(dragEl);
            dragEl.classList.add('dragging');
            
            startX = e.clientX;
            startY = e.clientY;
            startLeft = parseFloat(dragEl.style.left) || 0;
            startTop = parseFloat(dragEl.style.top) || 0;
            
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          }

          function onMove(e){
            if(!dragEl) return;
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            let x = startLeft + dx;
            let y = startTop + dy;
            
            const boardRect = whiteboard.getBoundingClientRect();
            x = Math.max(0, Math.min(boardRect.width - dragEl.offsetWidth, x));
            y = Math.max(0, Math.min(boardRect.height - dragEl.offsetHeight, y));
            
            dragEl.style.left = x + 'px';
            dragEl.style.top = y + 'px';
          }

          function onUp(e){
            if(!dragEl) return;
            dragEl.classList.remove('dragging');
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            dragEl = null;
            isTextEditing = false;
          }

          whiteboard.addEventListener('mousedown', onDown, {capture: true});
        })();
      })();
    </script>
  </div>
</body>
</html>